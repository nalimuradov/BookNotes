

stanford

decomposition programming


SOURCE CODE and OBJECT CODE



Java graphics

includes:
Glabel (just text)
GRect (rectangle)
GOval (ovals)
Gline (lines)

These are classes and you can use them to create objects
Because classes are templates for objects

add instances (objects) to put on collage

an object: GLabel label = new GLabel("Hello", 150, 100);
label.setFont("SansSerif-36");
label.setColor(Color.RED)

other graphics methods include getWidth() and getHeight()

it goes: name of object, followed by dot operator, followed by Method (eg. setFont)

add(label);

applies to all GObjects:

object.setColor(color)
object.setLocation(x, y)
object.move(dx, dy)

java.awt.* has all basic colors

Constructor: 
	new GRect(x, y, width, height)


double y = (double)x/2;

cast - can be used to temporarily make a type into a diff type

private static final {int x = 5;} that is entered outside the methods is a constant 

break - takes you out of the loop its in

for loop - for (init; test; step) { statement }

while - init while (test) { statement, step}


METHODS

receiver.name(arguments) - methods

eg label.setColor(Color.RED);

VISIBILITY TYPE NAME(PARAMETERS)

vis: private public (pretty much only run should be public)

private- only other methods in the same class can see it

type: type of return value (eg if it gives you a double) ( void is a special type_
(void means nothing is returned) 

method is an object where a function is not

import acm.util.* for random generator

int nextInt(int low, int high) gives rand int inclusive of low and high
int nextInt(int n) gives int between 0 and n-1
same for boolean, double, and color

COSNTRUCTORS

share name with method

does not specify a return tupe

responsible for initializing object

is called when an object is created


THIS

this.counter = counter;

"this" referes to receiver object
will look for an instance variable directly
will not look for local 

OR just give parameters different names as 'this' gets confusing



INTERFACE

set of methods

set of classes that have that set of methods

GFillable is an interface of GObject
direct hiearchy doesnt hold
eg GLabel is also GObject but not fillable

GImage
another object
image.scale(1.5)
GImage("file", x, y)

GCompound - stuff added together

** GArc and GLabel pointers towards end of lecture 10 **

Events 
addMouseListeners in the init/run
addKeyListeners in the init/run
init - initialize instead of run
synchronous vs asynchronous

USE PRIVATE INSTANCE VARS at bottom of program to keep track of objects

eg. private GObject hobj;
private GPoint last; (can hold an x and y location)








- - - - - - - - - - - - -

Cont from beginning of video 12

LECTURE 12

-Strings have method called charAt that takes char from String at index n

-chars are sequential accodring to ASCII (eg. 'a' to 'z')
	- therefore we can do inequalities, math, and loops on chars
		- eg. for (char c = 'A', while char < 'Z', char++)

-common methods for strings and chars in lecture 12



LECTURE 13

-String manipulation 

Tokenization
	- improt java util * to be able to tokenize strings
	- tokens are basically words seperated by spaces
		- eg. "hello, john" -> tokens are "hello," and "john"

	- can make tokenizer objects when util imported
		- StringTokenizer token = new StringTokenizer("input");

	- method hasMoreTokens();
		- boolean value
		- can be used as a condition for a loop

Encryption
	- Caesar Cipher


LECTURE 14

Memory
	- Bit: Either a 1 or 0
	- Byte: 8 bits
	- Word: Size of integer
		- In Java, this is 4 Bytes (32 bits)

- One Kilobyte is 1024 bytes (or kibibyte)

Hexadecimal
	- Base 16
	- Reason to use is for addresses
		- To distinguish hexadecimal addresses from the binary contents

Memory Storage
	- Static Variables and Constants stored in Special Memory
		- Need to be somewhere in memory so we can refer them'
		- We don't change them so just allocate them and (above line)

	- Dynamic Variable
		- eg. new GOval
		- Stored in Heap
		- sets aside memory as long as variable is being used
		- when variable will not be used again, the heap takes memory back

	- Local Variables and parameters
		- come from a place called the stack
		- sets aside memory to use for local variables and parameters
		- as soon as those variables leave scope, the stack takes that memory back


Visual
	- Static Special stored in low memory
		- low memory means address is like 1000 low number
	
	- Heap grows downwards
		- eg starts at 2000
		- can use 2004, 2008, expand as needed

	- The stack starts at very high memory
		- eg. FFFF
		- stack grows upwards

	- If stack and heap ever meet, error occurs
		- This rarely happens though as we have so much damn memory

- If you don't say 'new', it doesn't show up on the heap
	- eg. objects are on heap, integers are on stack

Refer to image 'MEMORY ALLOCATION 1 and 2' in Code Folder


- Pointers refer to memory address
	- In Memory Allocation image, it's the 1000, 100C on the stack in the boxes

- If you do Point p1 = p2; without 'new'
	- all this does is set the pointers equal to each other

LECTURE 15

-we don't care where something is located in memory 
 	- as long as we can refer to it with pointers
	- eg. call point1.move(1,3)	
		- looks for point1 on stack which points to px and py on heap

primitive types
	- double, int, char, boolean
 	- when passed as a parameter, we get a copy of the value of the primitive

Objects on the other hand
	- when passed around, the object ITSELF will be changed (not a copy)

immutable
	- once created, cannot change (eg. strings)
 
Files
	- reading files (import java.io.*)
	- BufferedReader rd = new BufferedReader(new FileReader("Students.txt"));
	- FileReader gets the file and BufferedReader reads it line by line
	- String line = rd.readLine();
	- if line is empty, it will return null

Exception
	- if FileReader looks up for file that doesn't exist, it "throws" an exception
	- try the code, then catch the exception if it happens (try catch statement)

Writing to Files
	- ***.println
	- PrintWriter wr = new PrintWriter(new FileWriter("copy.txt"));
	- wr.println("hello");

LECTURE 16

Arrays
	- type[] name = new type[size]
 	- actual size (how much initially declared) vs effective size (actually used)
	- if don't know size:
		- use sentinel on big array, then copy into another array of correct size

Post and pre-increment
	- x++ and ++x

If i pass an array as a parameter, it will pass like an object 
	- ie. the original array will be changed

ArrayList
	- import java.util.*
	- to declare: ArrayList<type> name = new ArrayList<type>();
	- name.add("hello") .... adds it to the end of the array list
	- name.get(i) .... get the element at the i'th position

LECTURE 17

Multidimensional Arrays
	- A matrix is a 2d array
	- int[][]

Generic Types <T> 

Array lists hold objects (must be Integer instead of int)
	- But java 5 now allows automatic boxing/unboxing
	- so we can do list.add(x) where x is an int instead of an integer

Monitor Screen is Pixels
	- each pixel is made up of red, blue, green
	- we get color by manipulating the intensity of each	
	- can get pixel array for a GImage
	- int[][] arr = image.getPixelArray();

LECTURE 18

If we have multidimension array called arr[][]
	- then just arr[] would be an array of arrays
	- lengths will differ eg. array[0].length and array.length
	- first will give length of first subarray, the other will return number of subarrays

If don't know size of array, use arraylist
If fixed size known, almost always use array

Debugging
	- Design: Architect
	- Coding: Engineer
	- Testing: Vandal
	- Debugging: Detective

Errors
	- bad values
	- faulty logic
	- unwarranted assumption

BreakPoint
	- click on sidebar grey to break there in the code
	- then at the top click DEBUG

LECTURE 19

Interface
	- common set of methods that classes share
	- "common functionality among a certain set of classes"
	- public class CLASSNAME implements INTERFACENAME
	- extending a class means direct correlation (eg. humans extend primate)
	- implementing could be like GIntelligence (dolphins and humans have but not all primates)

Map
	- is an interface in Java
	- have keys and values 
	- a way of associating a particular key with a particular value

HashMap
	- a class that implements the class interface
	- ** Map isn't a class, it just has methods we can use
	- has 2 types involved, a type for keys (eg. integers) and a type for value (eg. objects)
	- for dictionary, would be: HashMap<String, String> dict = new HashMap<String, String>();
	- for phone book: HashMap<String, Integer> **can't be int as it is a primitive
	- sometimes written as Map<String, String> dict = new HashMap<String, String>();
		- also works since HashMap is a Map (either one is good)
	- 2 main methods: put and get
		- dict.put(key, value);
		- dict.get(key);

Collection
	- a big hierarchy eg. ArrayList and LinkedList all implement a Collection

General Map
	- both TreeMaps and HashMaps implement maps but all that we care about is that it's a map
	- only difference between tree and hash is under the hood implementation
	- the abstraction is the same
	- in future, someone could create super great type of map but it will still be a map	
		- so it will have same methods and stuff

Iterator
	- list through set of values
	- eg. ArrayList<String> names = new ArrayList<String>();
	- iterator allows us to go through each value in 'names' one by one 
	- so we need: Iterator<String> it = names.iterator();
		- then we do: while (it.hasNext()){ println(it.next())};
	- a hashmap doesn't have iterator, but we can make it give its set of keys to iterate through
		- phonebook.keySet().iterator(); - this will give set of keys of phoneBook

New For Loops
	- for (String name: __Collection__) { ... }
	- eg. for (String name: phonebook.keySet()){ ... }